stages:
  Get TDM_SYNC_SOURCE_DATA:
    transactional: false
    actors:
      Get Variable TDM_SYNC_SOURCE_DATA:
        parent: FabricSetRead
        in:
          key:
            const: TDM_SYNC_SOURCE_DATA
            default: false
      Get Delete Only Task Indicator:
        parent: FabricSetRead
        in:
          key:
            const: TDM_DELETE_ONLY_TASK
            default: false
      Get Delete Before Load indicator:
        parent: FabricSetRead
        in:
          key:
            const: TDM_DELETE_BEFORE_LOAD
            default: false
      Get Is Child LU Indicator:
        parent: FabricSetRead
        in:
          key:
            const: CHILD_LU_IND
            default: false
  Check Variable And Delete Root Table:
    dependsOn: Get TDM_SYNC_SOURCE_DATA
    actors:
      Check TDM_SYNC_SOURCE_DATA:
        parent: Equals
        condition: result
        in:
          a:
            link: Get Variable TDM_SYNC_SOURCE_DATA/result
            schema: string
          b:
            const: 'true'
            schema: string
      Delete Root Table:
        parent: DbCommand
        in:
          interface:
            const: fabric
          sql:
            const: delete from {{__LU_NAME}}.{{{SOURCE_TABLE}}}
          table:
            external: table
            schema: string
    split: '--------------------'
  Instance should not be synced:
    else: true
    transactional: false
    dependsOn: Get TDM_SYNC_SOURCE_DATA
    actors:
      Check if first Sync:
        parent: LuFunction
        in:
          functionName:
            const: fnIsFirstSync
        out:
          firstSyncInd:
            schema: boolean
      Not1:
        parent: Not
        in:
          value:
            link: Get Delete Only Task Indicator/result
            schema: string
  Input:
    dependsOn: Check Variable And Delete Root Table
    actors:
      PopulationArgs:
        parent: PopulationArgs
        readonly: true
        in:
          '{{KEY}}':
            external: '{{KEY}}'
            schema: any
        out:
          parent_rows:
            schema: '#ref'
      Init Instance As Not Found:
        parent: JavaScript
        in:
          script:
            const: flowArgs.instanceFound = false;
        out:
          result:
            schema: boolean
    split: '--------------------'
  if First Sync Throw Exception:
    transactional: false
    dependsOn: Instance should not be synced
    actors:
      First Sync Is True and Not A Delete Only Task:
        parent: And
        condition: result
        in:
          a:
            link: Check if first Sync/firstSyncInd
          b:
            link: Not1/result
      Throw Exception:
        parent: JavaScript
        in:
          script:
            const: 'throw "The instance does not exist in Fabric and sync from source is off"'
  Parent Rows Mapper:
    dependsOn: Input
    actors:
      BqParentRowsMapper:
        parent: LuFunction
        in:
          functionName:
            const: bqParentRowsMapper
          lu:
            external: schema
            schema: string
            mandatory: false
          table:
            external: table
            schema: string
            mandatory: false
          parentRows:
            link: PopulationArgs/parent_rows
            schema: '#ref'
            mandatory: false
        out:
          result:
            schema: '#ref'
    split: '--------------------'
  Stage 6:
    transactional: false
    dependsOn: if First Sync Throw Exception
  Source:
    dependsOn: Parent Rows Mapper
    actors:
      Query:
        parent: SourceDbQuery
        in:
          interface:
            const: {{SOURCE_INTERFACE}}
          sql:
            const: select * from `$projectId.{{SOURCE_SCHEMA}}.{{{SOURCE_TABLE}}}`
          rowsGeneratorDistribution:
            const: '1'
            schema: object
          parent_rows:
            link: BqParentRowsMapper/result
        out:
          result:
            schema: '#ref'
      Get Tables Fields:
        parent: LuFunction
        in:
          functionName:
            const: getLuTableColumns
          luName:
            const: {{__LU_NAME}}
            schema: string
          table:
            const: {{{SOURCE_TABLE}}}
            schema: string
        out:
          res:
            schema: '#ref'
      ToBool1:
        parent: ToBool
        in:
          value:
            link: Get Delete Before Load indicator/result
      ToBool2:
        parent: ToBool
        in:
          value:
            link: Get Is Child LU Indicator/result
      Get SEQ_CACHE_INTERFACE:
        parent: FabricSetRead
        in:
          key:
            const: SEQ_CACHE_INTERFACE
            default: false
      Get MASKING_CACHE_TTL:
        parent: FabricSetRead
        in:
          key:
            const: MASKING_CACHE_TTL
            default: false
    split: '--------------------'
  Do Nothing:
    transactional: false
    dependsOn: Stage 6
  Move the query result to ArrayBuilder:
    remark: |
      This stage is needed in order to invoke the Query output twice â€“ sending it to the Catalog Actor and to the Masking Actor if we need to override the catalog logic.
    dependsOn: Source
    actors:
      ArrayBuilder1:
        parent: ArrayBuilder
        in:
          input:
            link: Query/result
        out:
          array:
            schema: '#ref'
    split: '--------------------'
  Stage 3:
    transactional: false
    dependsOn: Do Nothing
  Catalog masking:
    dependsOn: Move the query result to ArrayBuilder
    actors:
      Catalog Masking Mapper:
        parent: CatalogMaskingMapper
        in:
          interface:
            const: null
            link: Get SEQ_CACHE_INTERFACE/result
          mtable:
            schema: any
          dataPlatform:
            const: {{SOURCE_INTERFACE}}
          schema:
            const: {{SOURCE_SCHEMA}}
          dataset:
            const: {{{SOURCE_TABLE}}}
          ttl:
            link: Get MASKING_CACHE_TTL/result
            schema: number
            mandatory: false
          values:
            link: ArrayBuilder1/array
        out:
          values:
            schema: '#ref'
    split: '--------------------'
  Stage 2:
    transactional: false
    dependsOn: Stage 3
  Stage 1:
    dependsOn: Catalog masking
    actors:
      MaskingEmail1:
        parent: MaskingEmail
        in:
          maskingId:
            const: email
          interface:
            link: Get SEQ_CACHE_INTERFACE/result
          value:
            link: Catalog Masking Mapper/values/email
          firstName:
            link: Catalog Masking Mapper/values/first_name
          lastName:
            link: Catalog Masking Mapper/values/last_name
        out:
          value:
            schema: string
    split: '--------------------'
  Stage 4:
    transactional: false
    dependsOn: Stage 2
  Set instance As Found:
    dependsOn: Stage 1
    actors:
      Instance Is Found In Source:
        parent: JavaScript
        in:
          script:
            const: flowArgs.instanceFound = true;
        out:
          result:
            schema: boolean
    split: '--------------------'
  Do Nothing 1:
    transactional: false
    dependsOn: Stage 4
  LU Table:
    last: 1
    dependsOn: Set instance As Found
    actors:
      Root Table:
        parent: DbLoad
        in:
          interface:
            const: fabric
          schema:
            const: null
            external: schema
          table:
            const: null
            external: table
          fields:
            const: null
            link: Get Tables Fields/res
          keys:
            const:
              - {{KEY}}
          dialect:
            const: sqlite
          email:
            link: MaskingEmail1/value
            schema: string
            mandatory: false
          params:
            link:
              path: Catalog Masking Mapper/values
              iterate: Iterate
    split: '--------------------'
  Do Nothing 2:
    last: 1
    transactional: false
    dependsOn: Do Nothing 1
  Post Load:
    dependsOn: LU Table
    actors:
      Check if Instance Was Not Found In Source:
        parent: JavaScript
        in:
          script:
            const:
              userCode: "if ((deleteBeforeLoad == false || isChildLu == false ) \r\n  && flowArgs.instanceFound == false) {\r\n    throw \"Instance \" + iid + \" is not found in the Source\"\r\n}"
              script: |-
                if ((deleteBeforeLoad == false || isChildLu == false) && flowArgs.instanceFound == false) {
                  throw "Instance " + iid + " is not found in the Source";
                }
          iid:
            link: PopulationArgs/iid
            schema: string
          deleteBeforeLoad:
            link: ToBool1/bool
            schema: boolean
            mandatory: false
          isChildLu:
            link: ToBool2/bool
            schema: boolean
            mandatory: false
    split: '--------------------'
  Do Nothing 3:
    transactional: false
    dependsOn: Do Nothing 2
schemas:
  PopulationArgs.out.parent_rows:
    type: array
    items:
      type: object
      properties:
        {{KEY}}:
          type: string
  BqParentRowsMapper.in.parentRows:
    type: array
    items:
      type: object
  BqParentRowsMapper.out.result:
    type: array
    items:
      type: object
  Query.out.result:
    type: array
    items:
      type: object
  Get Tables Fields.out.res:
    type: array
    items:
      type: string
  ArrayBuilder1.out.array:
    type: array
    items:
      type: object
  Catalog Masking Mapper.out.values:
    type: array
    items:
      type: object
